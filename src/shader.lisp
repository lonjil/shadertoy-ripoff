(in-package #:shadertoy-pyx.shader)

(defun vertex ((pos :vec2)
               (uv :vec2)
               &uniforms
               (model :mat4)
               (view :mat4)
               (proj :mat4))
  (values (vec4 (* pos 2) 0 1)
          pos))

(defun fragment ((uv :vec2)
                 &uniforms
                 (res :vec2)
                 (mouse :vec2)
                 (time :float)
                 (tex :sampler-2d))
  (let ((p (/ (* 2 uv res) (.y res))))
    (vec4 (image p mouse time tex) 1)))

(define-shader test ()
  (:vertex (vertex :vec2 :vec2))
  (:fragment (fragment :vec2)))

(defun blit-vert ((pos :vec2)
                  (uv :vec2)
                  &uniforms
                  (model :mat4)
                  (view :mat4)
                  (proj :mat4))
  (values (vec4 (* 2 pos) 0 1)
          uv))
(defun blit-frag ((uv :vec2)
                  &uniforms
                  (sampler :sampler-2d))
  (texture sampler uv))
(define-shader blit ()
  (:vertex (blit-vert :vec2 :vec2))
  (:fragment (blit-frag :vec2)))


(defun raymarch ((ro :vec3) (rd :vec3))
  (let ((d 1f-3))
    (dotimes (i 100)
      (let* ((p (+ ro (* d rd)))
             (h (map p)))
        (when (< h 0.001) (break))
        (incf d h)
        (when (> d 20) (setf d -1f0) (break))))
    d))
(defun intersect ((ro :vec3) (rd :vec3) (time :float))
  (let ((d 1f-3)
        (pr (vec3 0)))
    (dotimes (i 100)
      (let* ((p (+ ro (* d rd)))
             (h (map p time)))
        (setf pr (.yzw h))
        (when (< (.x h) 0.001) (break))
        (incf d (.x h))
        (when (> d 20) (setf d -1f0) (break))))
    (vec4 d pr)))

(defun hard-shadow ((ro :vec3) (rd :vec3))
  (step (raymarch ro rd) 0f0))

(defun soft-shadow ((ro :vec3)
                    (rd :vec3)
                    (w :float))
  (let ((s 1f0)
        (ph 1f20)
        (dist 1f-4))
    (dotimes (i 100)
      (let ((h (map (+ ro (* rd dist)))))
        (when (< h 1f-7) (break))
        (let* ((y (/ (* h h) (* 2.0 ph)))
               (d (sqrt (- (* h h) (* y y)))))
          (setf s (min s (+ 0.5 (/ (* d 0.5) (* w (max 0 (- dist y))))))
                ph h)
          (incf dist h))))
    s))
(defun soft-shadow ((ro :vec3)
                    (rd :vec3)
                    (w :float)
                    (time :float))
  (let ((s 1f0)
        (ph 1f20)
        (dist 1f-4))
    (dotimes (i 100)
      (let ((h (map (+ ro (* rd dist))) time))
        (when (< h 1f-7) (break))
        (let* ((y (/ (* h h) (* 2.0 ph)))
               (d (sqrt (- (* h h) (* y y)))))
          (setf s (min s (+ 0.5 (/ (* d 0.5) (* w (max 0 (- dist y))))))
                ph h)
          (incf dist h))))
    s))
(defun normal ((pos :vec3))
  (let ((e (vec2 1f-4 0f0)))
    (normalize (vec3 (- (map (+ pos (.xyy e))) (map (- pos (.xyy e))))
                     (- (map (+ pos (.yxy e))) (map (- pos (.yxy e))))
                     (- (map (+ pos (.yyx e))) (map (- pos (.yyx e))))))))

(defun normal ((pos :vec3) (time :float))
  (let ((n (vec3 0f0)))
    (dotimes (i 4)
      (let ((e (* 0.5773
                  (- (* 2.0 (vec3 (logand 1 (vari.cl::>> (+ i 3) 1))
                                  (logand 1 (vari.cl::>> i 1))
                                  (logand 1 i)))
                     1.0))))
        (incf n (* e (.x (map (+ pos (* 5e-4 e)) time))))))
    (normalize n)))
(defun ao ((pos :vec3) (nor :vec3) (time :float))
  (let ((occ 0f0)
        (sca 1f0))
    (dotimes (i 5)
      (let* ((h (+ 0.01 (/ (* 0.12 i) 4)))
             (d (.x (map (+ pos (* h nor)) time))))
        (incf occ (* (- h d) sca))
        (multf sca 0.95)))
    (clamp (- 1.0 (* 3 occ)) 0 1)))

(defun rot ((a :float))
  (let ((s (sin a)) (c (cos a)))
    (mat2 c (- s) s c)))
(defun set-camera ((ro :vec3) (ta :vec3) (cr :float))
  (let* ((cw (vec3 (normalize (- ta ro))))
         (cp (vec3 (sin cr) (cos cr) 0))
         (cu (normalize (cross cw cp)))
         (cv (cross cu cw)))
    (mat3 cu cv cw)))

(defun smax ((a :float) (b :float) (k :float))
  (let ((h (max (- k (abs (- a b))) 0)))
    (+ (max a b) (* h h (/ 0.25 k)))))

(defun plane-dist ((p :vec3))
  (.y p))
(defun sphere-dist ((p :vec3)
                   (r :float))
  (- (length p) r))

(defun box-distance ((p :vec3) (b :vec3))
  (length (max (- (abs p) b) 0)))
(defun rect-distance ((p :vec2) (b :vec2))
  (length (max (- (abs p) b) 0)))
(defun cross-distance ((p :vec3) (b :vec3))
  (let* ((p (abs p)))
    (setf (.xz p) (if (> (.z p) (.x p)) (.zx p) (.xz p)))
    (box-distance p b)))
(defun vstick-distance ((p :vec3) (h :float))
  (let* ((xz (+ (expt (.x p) 2)
                (expt (.z p) 2)))
         (d (max (- (.y p) h) 0.0)))
    (sqrt (+ d xz))))

(defun gear ((p :vec3) (time :float) (offset :float))
  (setf (.xz p) (* (rot (+ (* (/ origin:pi 24) 2 offset)
                           (if (plusp (.y p))
                               time
                               ( - time)))) (.xz p)))
  (setf (.y p) (abs (.y p)))
  (let* ((angle (/ (* 2 origin:pi) 12))
         (sector (round (/ (atan (.z p) (.x p)) angle)))
         (q p)
         (an (* sector angle))
         (q (.xzy (vec3 (* (rot an) (.xz q)) (.y q))))
         (d1 (- (rect-distance (- (.xz q) (vec2 0.17 0))
                               (vec2 0.04 0.018))
                0.01))
         (d2 (- (abs (- (length (.xz p)) 0.155)) 0.018))
         (d1 (min d2 d1))
         (d2 (- (cross-distance (- p (vec3 0 0.5 0))
                                (vec3 0.15 0.005 0.005)) 0.003))
         (d1 (min d2 d1))
         (r (length p))
         (d1 (smax d1 (- (abs (- r 0.5)) 0.03) 0.005))
         (d2 (- (vstick-distance p 0.5) 0.01))
         (d1 (min d1 d2))
         (d d1))
    (vec4 d p)))

(defun rot45 ((v :vec2))
  (* (/ (sqrt 2)) (vec2 (- (.x v) (.y v)) (+ (.x v) (.y v)))))
(defun map ((p :vec3) (time :float))
  (let* ((d (vec4 (sphere-dist p 0.12) p))
         (qx (vec3 (rot45 (.zy p)) (.x p)))
         (qy (vec3 (rot45 (.xz p)) (.y p)))
         (qz (vec3 (rot45 (.yx p)) (.z p)))
         (qa (abs p)))
    (if (> (abs (.x qx)) (abs (.y qx))) (setf qx (.zxy qx)))
    (if (> (abs (.x qy)) (abs (.y qy))) (setf qy (.zxy qy)))
    (if (> (abs (.x qz)) (abs (.y qz))) (setf qz (.zxy qz)))
    (setf qa (if (and (> (.x qa) (.y qa)) (> (.x qa) (.z qa)))
                 (.zxy p)
                 (if (> (.z qa) (.y qa))
                     (.yzx p)
                     (.xyz p))))
    (let ((g (vec4 0)))
      (setf g (gear qa time 0f0))
      (if (< (.x g) (.x d)) (setf d g))
      (setf g (gear qx time 1f0))
      (if (< (.x g) (.x d)) (setf d g))
      (setf g (gear qy time 1f0))
      (if (< (.x g) (.x d)) (setf d g))
      (setf g (gear qz time 1f0))
      (if (< (.x g) (.x d)) (setf d g))
      d)))

(defun image ((pos :vec2) (mouse :vec2) (time :float) (sam :sampler-2d))
  (let* ((an (* 0.3 3))
         (ta (vec3 0))
         (ro (* 2.3 (+ ta (vec3 (* 0.5 (cos an)) 0.25 (* 0.5 (sin an))))))
         (ca (set-camera ro ta 0f0))
         (fl 2f0)
         (rd (* ca (normalize (vec3 pos fl)))))
    (let*  ((time (* time 0.2))
            (r (intersect ro rd time))
            (d (.x r))
            (col (vec3 0.0)))
      (when (> d 0)
        (let* ((p (+ ro (* d rd)))
               (nor (normal p time))
               (fin (+ 0.5 (* 0.5 nor)))
               (occ (ao (+ p (* nor 0.001)) nor time))
               (mat (+ (* 0.34 (.rgb (texture sam (.yz r))))
                       (* 0.34 (.rgb (texture sam (.yw r))))
                       (* 0.34 (.rgb (texture sam (.zw r))))))
               (mat (* mat mat 1.2))
               ;(sundir (normalize (vec3 0.8 0.4 -0.2)))
               ;(sundif (clamp (dot nor sundir) 0 1))
               ;(suncol (vec3 1 0.7 0.5))
               ;(sunsha (soft-shadow (+ p (* nor 1f-3)) sundir 0.2 time))
               ;(skydif (clamp (+ 0.5 (* 0.5 (dot nor (vec3 0 1 0)))) 0 1))
               ;(skycol (vec3 0 0.1 0.3))
               (lig (* occ (vec3 1)#+(or)(+ (* sunsha suncol) skycol))))
          (setf col (* mat lig))
          )
        )
      (setf col (expt col (vec3 (/ (sqrt 2.2)))))
      col)))



(defun old-image ((pos :vec2) (mouse :vec2) (time :float))
  (let* ((ro (vec3 0 0 -1))
         (rd (normalize (vec3 pos 1.25))))
    (let  ((d (raymarch ro rd))
           (col (vec3 0.0)))
      (when (> d 0)
        (let* ((p (+ ro (* d rd)))
               (nor (normal p))
               (sundir (normalize (vec3 0.8 0.4 -0.2)))
               (sundif (clamp (dot nor sundir) 0 1))
               (sunsha (soft-shadow (+ p (* nor 1f-3)) sundir 0.2))
               (skydif (clamp (+ 0.5 (* 0.5 (dot nor (vec3 0 1 0)))) 0 1)))
          (setf col (* sundif (vec3 1 0.7 0.5) sunsha))
          (incf col (* skydif (vec3 0 0.1 0.3))))
        )
      (setf col (expt col (vec3 (/ (sqrt 2.2)))))
      col)))
